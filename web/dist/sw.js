const CACHE_VERSION=1,CACHE_NAME="ELECV2P_SW1",CACHE_LIST_PRE=[],CACHE_URL=new Map([]),CACHE_HOST=new Map([["a.ogod.ml",0],["sponsors.elecv2.workers.dev",1]]),CACHE_SEARCH=new Map([["?type=sponsors&param=lists",1]]),CACHE_PATH=new Map([["/manifest.json",1],["/elecV2/elecV2P/master/logs/update.log",1],["/efss/logo/elecV2P.png",2],["/jsfile",2],["/store",2],["/data",2],["/eapp",2],["/sefss",2]]),CACHE_MODE=new Map([["navigate",2]]),CACHE_DESTINATION=new Map([["image",0],["script",0],["style",0],["font",0],["manifest",1],["document",2]]),STRATEGY_DEFAULT=-1,putInCache=async(e,a)=>{console.debug("cache",e.url,"type:",e.destination);const t=await caches.open(CACHE_NAME);await t.put(e,a)},eCache=async e=>{const a=await caches.match(e.request);if(a)return console.debug("serve",e.request.url,"from cache"),a},eFetch=async(e,a=!1)=>{try{if("navigate"===e.request.mode){const a=await e.preloadResponse;if(a)return console.debug("serve",e.request.url,"from preload"),putInCache(e.request,a.clone()),a}const a=await fetch(e.request);return putInCache(e.request,a.clone()),a}catch(t){if(a){console.error(t),console.debug("try get",e.request.url,"response from cache");const a=await eCache(e);if(a)return a}return console.error(t,e.request.url),new Response(`{ "rescode": -1, "message": "Network Error: ${t.message}"}`,{header:{"Content-Type":"application/json;charset=utf-8"}})}},STRATEGIES=[async e=>await eCache(e)||await eFetch(e),async e=>{const a=await eCache(e),t=eFetch(e);return a||await t},async e=>await eFetch(e,!0)],getStrategy=e=>{let a=-1,{url:t,mode:s,method:n,destination:c}=e;if("GET"!==n)return console.debug("fetch",t,s,n),a;let r=new URL(t),o=r.hostname,i=r.pathname,l=r.search,C="";switch(!0){case CACHE_URL.has(t):a=CACHE_URL.get(t),C="URL";break;case CACHE_HOST.has(o):a=CACHE_HOST.get(o),C="HOST";break;case CACHE_SEARCH.has(l):a=CACHE_SEARCH.get(l),C="SEARCH";break;case CACHE_PATH.has(i):a=CACHE_PATH.get(i),C="PATH";break;case CACHE_DESTINATION.has(c):a=CACHE_DESTINATION.get(c),C="DESTINATION";break;case CACHE_MODE.has(s):a=CACHE_MODE.get(s),C="MODE"}return-1===a||STRATEGIES[a]||(console.error("strategy",a,"not exist"),a=-1),console.debug("fetch",t,s,n,c,"strategy:",C,a),a},deleteCache=async e=>{console.debug("delete cache",e),await caches.delete(e)},deleteOldCaches=async()=>{const e=[CACHE_NAME],a=(await caches.keys()).filter((a=>!e.includes(a)));await Promise.all(a.map(deleteCache))};self.addEventListener("install",(e=>{console.debug("install"),self.skipWaiting(),e.waitUntil((async()=>{const e=await caches.open(CACHE_NAME);await e.addAll(CACHE_LIST_PRE)})())})),self.addEventListener("activate",(e=>{console.debug("activate"),e.waitUntil((async()=>{"navigationPreload"in self.registration&&await self.registration.navigationPreload.enable(),await deleteOldCaches()})()),self.clients.claim()})),self.addEventListener("fetch",(e=>{let a=getStrategy(e.request);-1!==a&&e.respondWith(STRATEGIES[a](e))}));